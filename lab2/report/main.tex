\documentclass[a4paper,14pt]{extarticle}
\input{/home/acesk/Documents/latex/preamble.tex}

\usepackage{fancyvrb}

\newcommand{\Code}[1]{\textit{#1}}

\setlength{\extrarowheight}{.5ex}

\begin{document}

\input{inc/titlepage}

\renewcommand*{\thepage}{}
\tableofcontents
\clearpage
\renewcommand*{\thepage}{\arabic{page}}

\setcounter{page}{3}

\anonsection{Цель работы}

Исследовать механизмы управления виртуальной памятью Win32.

\anonsection{Введение}

При выполнении лабораторной работы на языке программирования C стандарта C11
было разработано консольной приложение, управление которым происходит через
различные меню, содержащие подпункты и подменю, соответствующие пунктам
заданий. Исходный код приложения доступен на GitHub
\footnote{\url{https://github.com/stnrepin/os_labs/tree/master/lab2}}.

\begin{table}[H]
    \centering
    \begin{tabularx}{\textwidth}{|c|X|}
        \hline
        Файл & Описание \\
        \hline
        menu.c & Определение типов и функций для работы с меню \\
        \hline
        main.c & Точка входа в программу; объявления конкретных меню и
                    переходов между ними \\
        \hline
        actions.c & Реализация функций непосредственно выполняющих требования
                    заданий (другими словами, callback'и конечных пунктов меню)
                    \\
        \hline
        error.c & Описание номеров ошибок, а также функции отображения
                    сообщений об ошибках \\
        \hline
    \end{tabularx}
    \caption*{Таблица 1 Описание файлов в проекте}
\end{table}

Сборка проекта производится с помощью Powershell-скрипта \Code{build.ps1}
(следует создать папку \Code{build} и запускать скрипт из нее). Также
потребуется пакет Build Tools for Visual Studio 2019.


\clearpage

\section{Исследование виртуального адресного пространство процесса}


\subsection{Получение информации о вычислительной системе}

Используя функцию \Code{GetSystemInfo}, программа получается информацию о
системе, содержащую такие пункты, как: архитектура процессора, число логических
ядер процессора, размер страницы, гранулярность выделения памяти, минимальный
(максимальный) доступный для использования адрес памяти и другие.

\addimghere{res/111.png}{0.7}{Результат выполнения программы}{}


\subsection{Определение статуса виртуальной памяти}

Используя функцию \Code{GlobalMemoryStatus}, программа получает информацию о
виртуальной памяти компьютера: процент используемой памяти, общий размер
физической памяти, доступный размер физической памяти, общий размер виртуальной
памяти, доступный размер виртуальной памяти.

Заметим, что объемы физической и виртуальной памяти сильно отличаются. Размер
физической памяти ограничен конфигурацией оборудования (размером ОЗУ, в данном
случае), а виртуальной только операционной системой.

\addimghere{res/112.png}{0.7}{Результат выполнения программы}{}


\subsection{Определение состояния конкретного участка памяти}

Используя функцию \Code{VirtualQuery}, программа получает информацию о
состоянии участка памяти, расположенного по указанному адресу. В частности,
можно узнать о размере участка памяти, состояния страниц, доступности страниц.

\addimghere{res/12.png}{0.7}{Результат выполнения программы для адреса
0x00000fffffffffff. Заметим, что память, начиная с адреса
0x00000ffffffff000, доступна для аллокации}{}


\subsection{Резервирование региона памяти}

Используя функцию \Code{VirtualAlloc}, программа резервирует регион памяти
определенного размера по определенному адресу. Для резервирования с
автоматическим определением адреса региона памяти в функцию передается адрес
равный \Code{NULL}.

\addimghere{res/13_1.png}{0.7}{Результат выполнения программы для
резервирования участка размером 8192 байта в автоматическом режиме}{}

Попробуем выполнить запись в участок выделенной памяти. Очевидно, это не
получится сделать, так как виртуальная память была только лишь зарезервирована,
но ей не была выделена физическая память.

\addimghere{res/15_1.png}{0.7}{Программа завершается с ошибкой из-за доступа
к не выделенной памяти}{}

Теперь зарезервируем память по адресу 0x00000fffffffffff.

\addimghere{res/13_2.png}{0.7}{Результат выполнения программы для
резервирования участка размером 8192 байта}{}


\subsection{Резервирование региона памяти и передача
ему физической памяти}

Аналогично предыдущему пункту здесь используется функция \Code{VirtualAlloc},
которой, кроме того, передается параметр \Code{MEM\_COMMIT}, обязывающий
ОС передать региону физическую память после резервирования.

Заметим, что программа вернет ошибку, если память перед этим была уже
зарезервирована.

\addimghere{res/14_3.png}{0.7}{Результат выполнения программы для
выделения участка памяти размером 8192 байта в автоматическом режиме}{}
\addimghere{res/14_1.png}{0.7}{Программа выдает ошибку при использовании
зарезервированной памяти}{}
\addimghere{res/14_2.png}{0.7}{Результат выполнения программы для
выделения участка памяти размером 8192 байта по определенному адресу}{}
\addimghere{res/14_4.png}{0.7}{Проверка выполнения программы с помощью функции
\Code{VirtualQuery}}{}

\subsection{Запись и чтение данных по определенному адресу}

Используя функции \Code{memset}, \Code{memcpy} из стандартной библиотеки C,
программа записывает и читает данные по заданным пользователем адресам. Кроме
того, используя расширения компилятора Microsoft, программа с помощью
конструкции \Code{\_\_try-\_\_except} может определять попытки записи (чтения)
по недоступному адресу.

\addimghere{res/15_2.png}{0.7}{Запись трех байт}{}
\addimghere{res/16.png}{0.7}{Чтение ранее записанных трех байт}{}
\addimghere{res/15_1.png}{0.7}{Программа возвращает ошибку при попытки записи
данных в недоступные ячейки памяти}{}



\subsection{Установка защиты доступа}

С помощью функции \Code{VirtualProtect} программа может устанавливать
защиту доступа для заданного региона памяти.



\addimghere{res/17_1.png}{0.7}{Установка защиты доступа \Code{PAGE\_NOACCESS}}{}
\addimghere{res/17_2.png}{0.7}{Теперь запись данных в ячейки данного региона
не удается}{}



\subsection{Возврат физической памяти и освобождение региона}

Используя функцию \Code{VirtualFree}, программа освобождает регион адресного
пространства по заданному адресу и возвращает физическую память.


\addimghere{res/18.png}{0.6}{Освобождение памяти по адресу 0x00000fffffff0000}{}
\addtwoimghere{res/18_1.png}{res/18_2.png}{0.6}{%
Статус региона памяти по адресу 0x00000fffffff0000 до и после
освобождения}{}


\clearpage


\section{Использование проецируемых файлов для обмена данными между процессами}

Программа может быть использована в двух режимах: писатель (writer) и читатель
(reader).

В первом случае, программа создает специальный файл, проецирует его в память и
записывает данные в спроецированный файл (функции \Code{CreateFile},
\Code{CreateFileMapping}, \Code{MapViewOfFile}, \Code{UnmapViewOfFile},
\Code{memcpy}). Во втором случае, программа считывает этот файл, также
проецирует его в память и выполняет чтение данных (функции
\Code{OpenFileMapping}, \Code{MapViewOfFile}, \Code{UnmapViewOfFile},
\Code{memcpy}).

\addimghere{res/2.png}{1}{Слева программа в режиме писателя передает набор
байтов в программу справа, работающую в режиме читателя}{}

\clearpage

\anonsection{Вывод}

В ходе выполнения данной лабораторной работы были получены знания и практические навыки
низкоуровневой работы с виртуальной памятью при помощи Windows API. На практике
было разобрано устройство виртуальной памяти, ее отличие от физической памяти
и ее взаимосвязь с физической памятью. Был изучен подход в организации
виртуальной памяти в Windows -- страничная организация памяти. Кроме того,
теперь известны важные для практики особенности работы с памятью: так, например,
память выделяется постранично (то есть нельзя выделить память размером 1 байт),
а сам процесс выделения памяти разбивается на два отдельных процесса
(резервирование участка виртуальной памяти и непосредственное связывание ее с
физической памятью). Также, теперь очевидна польза от использования
hugepages-технологии для программ, часто выделяющих память и часто к ней
обращающихся.

Во втором задании к лабораторной работе было продемонстрировано важнейшее
свойство виртуальной памяти: предоставление унифицированного интерфейса к
физической памяти (источники которой могут быть различны, например: ОЗУ, SSD,
HDD). В данном случае источником памяти выступает файл из ФС, который
средствами Windows API проецируется в память, т.е. данным, хранящимся в файле,
ставится в соответствие некоторый диапазон адресов виртуальной памяти.
Дальнейшее взаимодействие с файлом происходит также, как и взаимодействие с
обычной памятью (чтение/запись данных памяти приводит к чтению/записи данных в
файле).

Таким образом, такой подход выступает гибким способом организации
межпроцессорного взаимодействия, позволяя использовать файл в качестве
связующего элемента между независимыми пространствами виртуальной памяти
каждого процесса (один процесс записывает данные по адресу, который принадлежит
проецированной памяти, автоматически операционной системой происходит запись в
проецированный файл, которая в свою очередь влечет изменение памяти второго
процесса по соответствующему адресу).

Кроме того, отображение файла в память дает серьезный выигрыш в
производительности операций чтения и записи файла, сокращая количество
системных вызовов, уменьшая количество используемой памяти и упрощая
взаимодействие с файлом (исчезает необходимость программы в промежуточном
буфере для хранения данных файла, так как этим теперь занимается только ОС).

\end{document}

