\documentclass[a4paper,14pt]{extarticle}
\input{/home/acesk/Documents/latex/preamble.tex}

\newcommand{\Code}[1]{\textit{#1}}

\setlength{\extrarowheight}{.5ex}

\begin{document}

\input{inc/titlepage}

\renewcommand*{\thepage}{}
\tableofcontents
\clearpage
\renewcommand*{\thepage}{\arabic{page}}

\setcounter{page}{3}

\anonsection{Цель работы}

Исследовать управление файловой системой с помощью Win32 API.

\anonsection{Введение}

При выполнении лабораторной работы на языке программирования C стандарта C11
было разработано консольной приложение, управление которым происходит через
различные меню, содержащие подпункты и подменю, соответствующие пунктам
заданий. Исходный код приложения доступен на GitHub
\footnote{\url{https://github.com/stnrepin/os_labs/tree/master/lab1}}.

\begin{table}[H]
    \centering
    \caption{Описание файлов в проекте}
    \begin{tabularx}{\textwidth}{|c|X|}
        \hline
        Файл & Описание \\
        \hline
        menu.c & Определение типов и функций для работы с меню \\
        \hline
        main.c & Точка входа в программу; объявления конкретных меню и
                    переходов между ними \\
        \hline
        actions.c & Реализация функций непосредственно выполняющих требования
                    заданий (другими словами, callback'и конечных пунктов меню)
                    \\
        \hline
        error.c & Описание номеров ошибок, а также функции отображения
                    сообщений об ошибках \\
        \hline
    \end{tabularx}
\end{table}

Сборка проекта производится с помощью Powershell-скрипта \Code{build.ps1}
(следует создать папку \Code{build} и запускать скрипт из нее). Также
потребуется пакет Build Tools for Visual Studio 2019.


\clearpage

\section{Управление дисками, каталогами и файлами.}


\subsection{Вывод списка дисков}

Используя функции \Code{GetLogicalDrives} и \Code{GetLogicalDriveStrings},
программа получается набор строк, содержащих названия логических дисков, и
отображает их на экране.

\addtwoimghere{res/11.png}{res/11_real.png}{0.6}{%
Результат выполнения программы и проверка с помощью Проводника}{}


\subsection{Вывод информации о диске}

Используя функции \Code{GetDriveType}, \Code{GetVolumeInformation},
\Code{GetDiskFreeSpace}, программа получает информацию о произвольном
существующем диске и отображает ее.

\addimghere{res/12.png}{0.6}{Результат выполнения программы}{}


\subsection{Создание и удаление директорий}

Используя функции \Code{CreateDirectory} и \Code{RemoveDirectory}, программа
создает и удаляет директории соответственно.

Заметим, что в программа также добавлена возможность передачи аргумента
командной строки, при получении которого программа меняет текущую директории
при запуске с помощью функции \Code{SetCurrentDirectory}.

\addtwoimghere{res/131.png}{res/131_real.png}{0.6}{%
Создание директории и проверка с помощью Проводника}{}
\addtwoimghere{res/132.png}{res/132_real.png}{0.6}{%
Удаление директории и проверка с помощью Проводника}{}


\subsection{Создание файлов}

Используя функцию \Code{CreateFile} с модификатором \Code{CREATE\_NEW},
программа создает файлы.

\addtwoimghere{res/14.png}{res/14_real.png}{0.6}{%
Создание файла и проверка с помощью Проводника}{}


\subsection{Копирование и перемещение файлов с учетом перемещения на место
существующих файлов}

Используя функции \Code{CopyFile}, \Code{MoveFile} и \Code{MoveFileEx},
программа копирует, перемещает и перемещает с заменой файлы и директории
соответственно.

\addtwoimghere{res/151.png}{res/151_real.png}{0.6}{%
Копирование файла и проверка с помощью Проводника}{}
\addtwoimghere{res/152.png}{res/152_real.png}{0.6}{%
Перемещение файла и проверка с помощью Проводника}{}
\addtwoimghere{res/153.png}{res/153_real.png}{0.6}{%
Перемещение файла на место существующего файла и проверка с помощью Проводника}{}


\subsection{Анализ и изменение атрибутов файлов}

Используя функции \Code{GetFileAttributes} и \Code{SetFileAttributes},
программа получает и устанавливает атрибуты файлов (заметим, что набор
атрибутов, доступных для получения, и набор атрибутов, доступный для установки,
отличаются количественно в пользу первого). Получение информации о файле в ФС
производится функцией \Code{GetFileInformationByHandle}. Для получения и
установки времени создания, последнего доступа и последнего изменения файла в
программе используются функции \Code{GetFileTime} и \Code{SetFileTime}
(обратите внимание, что эти функции не учитывают текущий часовой пояс, поэтому
результат этих функций может отличаться от той информации, которую
предоставляет системы.

\addtwoimghere{res/162.png}{res/162_real.png}{0.6}{%
Установка атрибутов файла и проверка с помощью Проводника}{}
\addimghere{res/161.png}{0.6}{Получение ранее установленных атрибутов из
программы}{}
\addimghere{res/163.png}{0.6}{Получение информации о файле}{}
\addtwoimghere{res/165.png}{res/165_real.png}{0.6}{Установка времени создания,
времени доступа и времени изменения файла, и проверка с помощью Проводника}{}
\addimghere{res/164.png}{0.6}{Получение ранее установленных времени создания,
времени доступа и времени изменения файла из программы}{}


\clearpage


\section{Копирование файла с помощью операций перекрывающегося ввода-вывода}

В этом задании с помощью функций \Code{ReadFileEx}, \Code{WriteFileEx},
\Code{SleepEx} в программу была добавлена возможность копирования указанного
файла операциями перекрывающегося ввода-вывода. Пользователю предоставляется
возможность указывать количества одновременных операций ввода-вывода и
множителя размера кластера, определяющего размер блоков, которыми копируется
файл. Произведем эксперимент по замеру скорости копирования
в зависимости от этих параметров.

Сперва, воспользуемся утилитой \Code{dd} из пакета GNU Core Utilities и
сгенерируем файл размером 30 MiB:
%
\begin{lstlisting}[language=Bash]
dd if=/dev/random of=file.bin bs=30MiB count=1
\end{lstlisting}
%

Зафиксируем количество количество операций ввода-вывода (возьмем 1) и замерим
время выполнения копирования при различных размерах блока. Произведем три
замера, найдем среднее арифметическое и построим график.

\begin{table}[H]
    \centering
    \caption{Результаты изменения времени}
    \begin{tabularx}{\textwidth}{|c|X|X|X|X|X|X|X|}
        \hline
                  & 1 & 2 & 4 & 8 & 12 & 16 & 20 \\
        \hline
                1 & 10266 & 5015 & 2609 & 2110 & 1640 & 1532 & 1110 \\
        \hline
                2 & 10094 & 5594 & 2938 & 2156 & 1641 & 1547 & 813  \\
        \hline
                3 & 9703  & 5250 & 3297 & 2094 & 1625 & 1532 & 1093 \\
        \hline
        $\Bar{S}$ & 10021 & 5286 & 2948 & 2120 & 1635 & 1537 & 1005 \\
        \hline
    \end{tabularx}
\end{table}

После каждого опыта была проведена проверка корректности выполнения операции
копирования с помощью утилиты \Code{FC}.

\addimghere{res/plot1.png}{1}{График зависимости времени копирования от размера
блока (при одной операции ввода-вывода)}{}

На графике видно, что скорость прямо пропорциональна размеру блока. Вероятно,
это происходит из-за обратной зависимости между размером блока и количеством
операций ввода-вывода, тем самым большой размер блока позволяет минимизировать
число дорогих операций.


Зафиксируем размер блоков (например, возьмем 4 размера кластера) и замерим
время выполнения копирования при различном количестве операций ввода-вывода.
Аналогично предыдущему опыту произведем три замера, найдем среднее
арифметическое и построим график.

\begin{table}[H]
    \centering
    \caption{Результаты изменения времени}
    \begin{tabularx}{\textwidth}{|c|X|X|X|X|X|X|X|}
        \hline
                  & 1 & 2 & 4 & 8 & 12 & 16 & 20 \\
        \hline
                1 & 4000 & 2375 & 1921 & 1391 & 1000 & 1343 & 1609 \\
        \hline
                2 & 3313 & 2031 & 1734 & 1359 & 984  & 1219 & 1329 \\
        \hline
                3 & 2890 & 2703 & 2031 & 1359 & 906  & 1390 & 1475 \\
        \hline
        $\Bar{S}$ & 3401 & 2369 & 1895 & 1369 & 963  & 1317 & 1471 \\
        \hline
    \end{tabularx}
\end{table}

После каждого опыта была проведена проверка корректности выполнения операции
копирования с помощью утилиты \Code{FC}.

\addimghere{res/plot2.png}{1}{График зависимости времени копирования от
количества операций ввода-вывода (при размере блока равным 4 размерам
кластера)}{}

На графике видно, что максимальная скорость достигается при 12 операциях
ввода-вывода. Увеличение времени при дальнейшем возрастании числа операций
объясняется возрастанием числа системных вызовов, что приводит к частым
переключениям контекста, которые занимают ощутимое время.


\clearpage


\anonsection{Вывод}

В ходе выполнения данной лабораторной работы были получены знания и практические навыки
низкоуровневой работы с файловой системой при помощи Windows API. Было
продемонстрировано, что такой подход дает программисту широкие возможности для
работы с файлами и директориями, намного большие, чем обычно предоставляется
стандартной библиотекой языков, хотя с другой стороны, и приходится жертвовать
переносимостью программы. Параллельно, был изучен подход Windows API в работу с
Unicode, а также был получен опыт работы с мощной системой документации MSDN.

Отдельно стоит отметить, получение умений в работе с асинхронным выполнении
операций чтения и записи файлов. Как было показано в работе, этот метод дает
возможность многократного увеличения скорости работы с файлами.

\end{document}

