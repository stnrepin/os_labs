\documentclass[a4paper,14pt]{extarticle}
\input{/home/acesk/Documents/latex/preamble.tex}

\usepackage{fancyvrb}

\newcommand{\Code}[1]{\textit{#1}}

\setlength{\extrarowheight}{.5ex}

\begin{document}

\input{inc/titlepage}

\renewcommand*{\thepage}{}
\tableofcontents
\clearpage
\renewcommand*{\thepage}{\arabic{page}}

\setcounter{page}{3}

\anonsection{Цель работы}

Исследовать инструменты и механизмы взаимодействия процессов в Windows.

\anonsection{Введение}

При выполнении лабораторной работы на языке программирования C стандарта C11
было разработано 2 консольных приложения, соответственно для каждого задания.
Исходный код приложения доступен на GitHub
\footnote{\url{https://github.com/stnrepin/os_labs/tree/master/lab4}}.

Сборка проектов производится с помощью Powershell-скриптов \Code{build.ps1}
(следует создать папку \Code{build} и запускать скрипт из нее). Также
потребуется пакет Build Tools for Visual Studio 2019.

%\clearpage

\section{Реализация решения задачи о читателях-писателях}

Программа представляет собой один исполняемый файл, который в зависимости от
переданных аргументов командной строки может представляться Читателей, Писателем или Управляющим
(который запускает процессы Читателей и Писателей). Имеет следующую структуру:

\begin{table}[H]
    \centering
    \begin{tabularx}{\textwidth}{|c|X|}
        \hline
        Файл & Описание \\
        \hline
        main.c & Точка входа в программу; выбор нужных действия на основании
                    переданных аргументов \\
        \hline
        config.h & Определение констант \\
        \hline
        launcher.c & Реализация Управляющего: функций для запуска процессов
        Читателя и Писателя \\
        \hline
        error.c & Описание номеров ошибок, а также функции отображения
                    сообщений об ошибках \\
        \hline
        reader\_writer.c & Операции захвата ресурсов (различные файлы, семафоры
        и мьютексы), Читателя и Писателя \\
        \hline
    \end{tabularx}
    \caption*{Таблица 1 Описание файлов в проекте для Задания 1}
\end{table}

Задача заключается в организации совместного доступа набора процессов к одной
области памяти для записи и чтения. Те процессы, которые выполняют запись
называются Писателями, а те, что выполняют чтение --- читателями.

Алгоритм работы читателей следующий:
\begin{enumerate}
    \item Захватить необходимые ресурсы (открыть объекты семафоров, мьютексов и
        файлов)
    \item Зайти в бесконечный цикл
    \item Ожидать разрешения доступа к буферам для читателей (ожидание
        освобождения семафора читателей, он содержит число занятых буферов)
    \item Ожидать разрешения эксклюзивного доступа к буферу (ожидание мьютексов
        буферов, будет использован первый освободившейся буфер)
    \item Выполнить чтение
    \item Освободить доступ к буферу
    \item Предоставить новое вакантное место для писателя
        (освободить семафор писателей)
\end{enumerate}

Алгоритм работы писателя следующий:
\begin{enumerate}
    \item Захватить необходимые ресурсы (открыть объекты семафоров, мьютексов и
        файлов)
    \item Зайти в бесконечный цикл
    \item Ожидать разрешения доступа к буферам для писателей (ожидание
        освобождения семафора писателей, он содержит число свободных буферов)
    \item Ожидать разрешения эксклюзивного доступа к буферу (ожидание мьютексов
        буферов, будет использован первый освободившейся буфер)
    \item Выполнить запись
    \item Освободить доступ к буферу
    \item Предоставить новое вакантное место для читателя
        (освободить семафор читателей)
\end{enumerate}

В итоге выполнения программы при 9 Читателях, 9 Писателях и 17 буферах были
получены следующие логи:

\addimghere{res/logs.png}{1}{Фрагмент файлов журналов Читателей (слева) и
Писателей (справа)}{}

По журнальным файлам видно, что в каждый момент времени одновременно работает
17 процессов, что соответствует числу буферов. А доступ к буферу захватывается
Писателем или Читателем сразу же, как он освобождается.

Приведем графики смены состояний 5 процессов Читателей и 5 процессов Писателей
(при 17 буферах). На каждом графике изображена последовательность состояний
\[
    \{ init, wait, read, release, wait, read, wait, read, release \}
\]
По вертикальной оси расположены названия состояний процесса, а по
горизонтальной -- время (здесь и далее 4 старшие цифры удалены, так как везде
одинаковые); точками обозначены моменты перехода в состояние.  Заметим, что все
графики сильно друг на друга похожи, отличаясь только абсолютными значениями.

\clearpage

Графики Читателей:
\addimghere{res/r1.png}{1}{}{}
\addimghere{res/r2.png}{1}{}{}
\addimghere{res/r3.png}{1}{}{}
\addimghere{res/r4.png}{1}{}{}
\addimghere{res/r5.png}{1}{}{}

%\clearpage

Графики Писателей:
\addimghere{res/w1.png}{1}{}{}
\addimghere{res/w2.png}{1}{}{}
\addimghere{res/w3.png}{1}{}{}
\addimghere{res/w4.png}{1}{}{}
\addimghere{res/w5.png}{1}{}{}

Изобразим графики занятости некоторых произвольных буферов (1, 5, 7) при тех же
установках, что и ранее.

\addimghere{res/bufs.png}{1}{}{}

\section{Использование именованных каналов для реализации
сетевого межпроцессного взаимодействия}

В данном задании создается консольное приложение, работающее в двух режимах:
\begin{itemize}
    \item Сервер. Создает именованный канал, ожидает подключения клиента,
        производит запись данных в канал
    \item Клиент. Подключается к именованному каналу, асинхронно считывает
        данные и отображает их на экран
\end{itemize}

Пример выполнения программы приведен на рисунке ниже.

\addimghere{res/client_server.png}{0.8}{Передача сообщения от сервера (слева)
клиенту (справа)}{}

\clearpage

\anonsection{Вывод}

В ходе выполнения данной лабораторной работы были получены знания и
практические навыки организации взаимодействия процессов с помощью WinAPI. Для
этой цели были использованы как базовые элементы --- примитивы синхронизации
--- семафоры и мьютексы, так и более высокоуровневые механизмы --- именованные
каналы.

В первом задании было написано решение задачи о читателях-писателях, здесь
применялись семафоры и мьютексы для обеспечения эксклюзивного доступа к общей
для процессов памяти. Принцип их работы крайне схож: они оба ограничивают
количество потоков, имеющих общий доступ к критической секции, только у
семафора это число является параметром, задающимся при его создании, а у
мьютекса оно всегда равно 2 (поэтому мьютекс еще называют бинарным семафором).
В задаче с помощью мьютексов делается так, что только один процесс имеет доступ
к буферу в конкретный момент времени (буфер может быть разблокирован, а может
быть заблокирован), а с помощью семафоров --- так, что чтение данных и их запись
между собой не конфликтует (сначала происходит запись, а потом чтение). Это
все важно для корректности работы программы, так как в противном случае возникает
состояние гонки, считающееся неопределенным поведением, или чтение до записи,
что само по себе неправильно.

Рассматривая переходы процессов из одного состояния в другое видно, что для
всех них наблюдается схожая картина: каждый раз процесс ждет освобождения
буфера, производит над ним чтение или запись и снова возвращается в очередь,
передавая буфер читателю или писателю. Первые операции чтения/записи происходят
с минимальным временем ожидания, которое затем увеличивается из-за роста
количества работающих Читателей и Писателей. Причем заметим, что по графикам
занятости буферов видно, что над буфером постоянно совершаются чередующиеся
операции чтения или записи, которые никогда не пересекаются, а сам буфер
утилизируется практически непрерывно.

Во втором задании применяются именованные каналы для налаживания общения между
различными процессами. Главным преимуществом по сравнению с использованием
примитивов является то, что код программы становится намного проще как с точки
зрения написания, так и с точки зрения чтения. Как известно, ошибки связанные с
многопоточным и многопроцессным программированием тяжело поддаются диагностике,
поэтому упрощение такого кода очень важно.

\end{document}

